## 命令行下，转到frontend目录下, 输入 npm start 之后，前端的文件加载顺序分析如下：

frontend\package.json ==> "scripts": {    "start": "react-app-rewired start", 即调用下面的批处理命令并加上参数"start"
frontend\node_modules\.bin/react-app-rewired.cmd ==> "%_prog%"  "%dp0%\..\react-app-rewired\bin\index.js" %*
frontend\node_modules\react-app-rewired\bin\index.js ==> require.resolve('../scripts/' + script)
frontend\node_modules\react-app-rewired\scripts\start.js
     ==> 这里比较复杂，参见https://juejin.cn/post/6984319032744755237 介绍了 start.js 和 react-app-rewired的相关流程
     下代码开头引入的两个文件：
        scriptVerson: 可以去看下 ./utils/paths 这个文件，其实返回的是 react-scrips
        overrides: 就是从指定的地方比如在根目录下 config-overrides.js 读取我们自定义的一些 webpack 配置
        最终  require(`${scriptVersion}/scripts/start`);还是执行原来的 react-scripts 的 start 脚本
        结合起来就很明朗了， react-app-rewired其实就是利用 require.cache 添加缓存，使得在 react-scrips/start.js 里引入的实际上是我们修改后的配置来达到重写的目的。
frontend\node_modules\react-scripts\scripts\start.js  ->启动http server 结束，并调用openBrowser(urls.localUrlForBrowser); 打开浏览器url，启动过程结束。


后面就是由浏览器url来访问server，每一个访问的入口点都是react-mrp\frontend\src\index.js
frontend\src\index.js ==> 加载了react, APP, antd.less, index.less, mock, lib monitoer
            import React from "react";
            import ReactDOM from "react-dom";
            import App from "./App";
            import "antd/dist/antd.less";
            import "@/styles/index.less";
            import "./mock";
            import '@/lib/monitor';
            ReactDOM.render(<App />
frontend\src\App.js ==》加载了 redux,antd、store、router等
            import React, { Component } from 'react';
            import { Provider } from "react-redux";
            import { ConfigProvider } from "antd";
            import zhCN from "antd/es/locale/zh_CN";
            import store from "./store";
            import Router from "./router";
            
            class App extends Component {
              render() { 
                return (
                  <ConfigProvider locale={zhCN}>
                    <Provider store={store}>
                      <Router />
                    </Provider>
                  </ConfigProvider>
                );
*注：本项目主功能页面布局对应的代码位于/src/views/layout，除了登录页面路由之外，所有的主功能页面路由信息均在routeMap.js文件中进行配置。
*注：import除了可以引入根据export导出的模块名外，还可以引入目录，“./”开头表示当前目录下的子目录，其它的要从当前或上层node_modules找，找到目录后如有package.json，就根据main字段找到js文件，否则就默认取目录下的 index.js，所以本项目Router会从文件frontend\src\router\index.js中引入

frontend\src\router\index.js ==>
    import React from "react";
    import { HashRouter, Route, Switch, Redirect } from "react-router-dom";
    import { connect } from "react-redux";
    import { getUserInfo } from "@/store/actions";
    import Layout from "@/views/layout";
    import Login from "@/views/login";
        <HashRouter>
        <Switch>
          <Route exact path="/login" component={Login} />
          <Route
            path="/"
            render={() => {
              if (!token) {
                return <Redirect to="/login" />;
              } else {
                if (role) {
                  return <Layout />;
                } else {
                  getUserInfo(token).then(() => <Layout />);
                }
              }
            }}
          />
        </Switch>
      </HashRouter>
可以看到，未登录用户被导向Login模块，即login目录下的index.js，如果用户已登录, 被导向Layout模块。 "@/views/login"中的@符号是指src目录 

frontend\src\views\login\index.js ==> 可以看到login使用了redux保存user， login和getUserInfo是从@/store/actions的index中引入
  export default connect((state) => state.user, {login, getUserInfo })( WrapLogin );
  理解connect方法书写格式，上面写法第一个参数是es6对函数的简化写法，省略return和中括号，state.user本身就是一个多个属性的字段，所以不需要加冒号。
      
frontend\src\/store/actions/index.js ==> 这是个目录式的文件，把一系统action从各个小文件中引入并用export统一导出

在index.js中引入了一个mock，它拦截了系统的XMLHttpRequest原生方法，所以最终调用axios时，并没有实际发送数据给后端，而是直接返回了mock数据